之前的去噪声算法是简单地将周围像素额达均值替换当前的像素值。
很据概率论中关于方差的定义可知，如果9个像素值被平均了，均值的噪声标准差将除以3.
所以如果我们在图像上，为每一个像素值寻找另外9个和此像素值相同像素点，就可以将噪声除以3，如果找到16个相似的点，噪声将被除以4。
但是如何寻找相似的点呢？
和给定的像素点最相似的像素点没有理由是最近的点，因为在图像中经常出现的周期模式和拉长的边缘。所以扫描图像的大部分来寻找真正类似于要去噪的像素点的像素点，是合理的。
去早通过计算　最相似的图像的像素值的均值　来完成。相似度（当前噪声像素点和与他相比的像素点之间的相似度的评估）评估是通过比较在像素周围的整个图像窗口，不是仅仅通过颜色。这个新的过滤器叫做　非局部均值滤波：
公式中：
d( B(p),B(q)) :中心点在p和q的图像块的欧式距离，
f: 是一个递减函数
C(p)　是归一化因子。

因为对相似像素的寻找是在一个比较大的邻阈中，但是还是在本地相同的图像中，所以non-local是有些误导的。傅里叶方法是相对nlmeans来说　比较non-local的方法。
此non-local　means方法基于一个简单的观察，在计算欧式距离d(B(p)， B(q))时，像素块B(p)中的所有像素都具有相同的重要性，所以可以用权值f(d( B(p),B(q))) 去除像素块B(p)中所有像素的噪声，不仅仅是p点的噪声。

2.像素方面的ｓｈｉｘｉａｎ
论文中的r表示的是搜索框，大小为(21*21)或者(35*35)，f表示的是块的大小。


关于rgb图像u(u1,u2,u3) 和待去噪的像素点p：
B(p,r)表示的是以p为中心点的相邻像素块区域，大小是(2r+1)*(2r+1)的像素块区域,r的取值可以是(21-1)/2或者(35-1)/2
搜索窗口:
不同于上述的像素块区域
比较温和的西格玛值　用21*21的搜索窗口
比较大的西格玛值　用35*35的搜索窗口


每个像素点都被还原成最相似的像素的恶平均值，在彩色图像中计算相似值的时候，每个通道分别进行计算，其中的w是相同的，计算公司朝份如下：

u_new(i) = (q属于B(p,r)的累加(u(i)(q)*w(p,q) )) / C(p);   计算式(1)
 
其中C(p) = q属于B(p,r)的累加(w(p,q)) 　计算式(2)


计算式(1)的解释：计算出来的i通道的新的像素值　是一个累加和，累加的是i通道q处的坐标值　乘以　p和q间的权值，其中q点属于以p(待计算的像素点)为中心，r为半径的矩形区域B(p,r).


C(p) 是像素块B(p,r)中所有w(p,q)的累加和。


权重w(p,q)的计算：

w(p,q) = exp(-(max(d*d-2*西格玛*西格玛,0.0))/(h*h))

其中h是和西格玛相关的数值

d的计算如下,计算的时候两个像素块以及三个通道都参与运算：

d*d(B(p,f),B(q,f)) = (i从1到3表示三个通道累加和(j从-r到r的累加和(u(i)(p+j) -u(i)(q+j) )*(u(i)(p+j) -u(i)(q+j) )　)  ) / (3*(2*r+1)*(2*r+1))
所以关于q相对于待测像素点p的权重，是两个像素块都参与运算计算来的。



时间复杂度：
表示图像大小:N*N
s搜索区域大小r (可以取值21*21)
窗口大小为f(可以取值为7)
通道数目为　c
复杂度为
N*N*c*f*f*r*r
因为要取搜索框中所有的元素找到一个f大小的窗口，所以对于每个窗口的计算量为f*f,同事搜索框中的所有元素都要进行f*f个计算，所以复杂度中包含f*f*r*r的计算量。

3 基于块的计算:

第一个公式B(i)的计算了某个块的值，其中累加的条件　所有的f*f大小的　属于r*r窗口的块　的累计
第三个公式　u(i)(p)的计算，累计下标为块，条件是块，块的中心不是属于r*r大小的p中线的窗口了，而是属于f*f大小中心为p的窗口。所以一共累加了(2*f+1)*(2*f+1)个块，归一化的时候也用的这个值　N*N = (2*f+1)*(2*f+1)
　



PSNR  峰值信噪比


上述两中方式的不同点在于：就两个方法的第一个公式来说，第一个方法的下表是对于(2*r+1)*(2*r+1)中的像素进行循环，会访问到窗口意外的元素，　而第二个方法中，使用的是在(2*r+1)*(2*r+1)窗口中的块，不会超出块的范围。



第二种方法中，用式三中的Q(写作Q1)替换式一中的B，
