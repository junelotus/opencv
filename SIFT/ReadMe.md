#步骤
高斯金字塔降采样得到   高斯金字塔
对组内的图像进行不同尺度的高斯模糊 
以下的尺度都是在组内的范围内讨论的
## DOG:高斯差分金字塔
组内的相邻两幅图像相减 得到近似HOG的DOG特征
## 组内尺度个数依据
因为得到一个尺度空间上的特征点，需要组内当前尺度上的点和上下两个尺度上的点进行比较，所以要得到n哥尺度上的特征点，需要有n+2哥DOG空间，而DOG空间是通过组内高斯模糊的图像相减产生的，所以最终结论是：亚像在组内得到s个空间尺度特征，需要组内开始有s+3张图像，得到s+2个DOG特征，再得到s个空间尺度的特征


##空间极值点的检测，关键点的初步探查
通过同一组内相邻的两侧DOG图像的比较完成。为了寻找DOG函数的极值点，每一个像素点要和它所有的相邻点进行比较，所有的相邻点包含上下相邻的DOG图像和本层图像的8连通区域，一共是3×9-1=26个点进行比较。保证在尺度空间和二维图像空间都检测到极值点。

## 构建尺度空间需要确定的参数
不同组相同层的组内尺度坐标相同。组内下一层图像是由前一层图像按进行高斯模糊所得。


https://www.cnblogs.com/ronny/p/4028776.html




## 尺度空间  多个高斯核和一副源图像生成一个高斯尺度空间。
𝐿(𝑥,𝑦,𝜎)表示由一个高斯滤波器与原图像卷积而生成的图像，即𝐿(𝑥,𝑦,𝜎)=𝐺(𝑥,𝑦,𝜎)⊗𝐼(𝑥,𝑦)。一系列的𝜎𝑖，则可以生成一系列的𝐿(𝑥,𝑦,𝜎𝑖)图像，此时我们把这一系列的𝐿(𝑥,𝑦,𝜎)图像称为原图像的一个尺度空间表示。
上述是说 一系列不同的kefai生成的多个图像，是一个尺度空间的图像。


多个尺度空间  是通过高斯金字塔 产生的各种近大远小的图像，然后在图像上使用相同的高斯核，等同于在都在原始图像上使用扩大倍数的高斯核，整个尺度空间中，DOG是连续的。

可见高斯金字塔的当前层图像是对其前一层图像先进行高斯低通滤波，然后做隔行和隔列的降采样(去除偶数行与偶数列)而生成的。当前层图像的大小依次为前一层图像大小的1/4。


信号的尺度空间刚提出是就是通过一系列单参数、宽度递增的高斯滤波器将原始信号滤波得到到组低频信号。那么一个很明显的疑问是：除了高斯滤波之外，其他带有参数t的低通滤波器是否也可以用来生成一个尺度空间。

## 用第i-1层的图像生成第i层的图像
而不是在原图 和此公式 𝜎=𝜎𝑜𝑘𝑜+𝑠/𝑆，其中,𝑘=2,𝑜∈[0,1,2,…,𝑛𝑂𝑐𝑡𝑎𝑣𝑒−1],𝑠∈[0,1,2,…,𝑆+2] 计算出来的滤波器计算当前的层的当前帧，而是通过上一层的图像计算当前层的图像，𝜎的计算公式为
𝑆𝑖𝑔𝑚𝑎𝐷𝑖𝑓𝑓𝑖=根号下（(𝜎0𝑘𝑖+1)2–(𝜎0𝑘𝑖)2）。
可是代码里依然用𝑆𝑖𝑔𝑚𝑎𝐷𝑖𝑓𝑓𝑖是因为这一层被降维了：这句话的意思是 图像已经利用高斯金字塔进行将维了。这句话类比于“从第-1层图像那里开始”，图过利用双线形插值将图像变为原始图像的两倍𝜎𝑛=0.5就变成了 2×𝜎𝑛，所以利用高斯金字塔，每次使用相同的𝑆𝑖𝑔𝑚𝑎𝐷𝑖𝑓𝑓𝑖在图像上，图像越小，表示在源图像上的𝑆𝑖𝑔𝑚𝑎𝐷𝑖𝑓𝑓𝑖越大。


## 利用泰勒展开式求取连续空间意义上的极值点 利用 一阶导数和二阶导数计算 结果

是三位空间阈上的，因为不仅只有图像上x y的坐标，还有尺度𝜎层面上的空间需要考虑。


## 尺度为𝜎的高斯差分图像DOG由于尺度为𝑘𝜎与尺度为𝜎的L图像生成的。𝑘为两相邻尺度空间倍数的常数。
## 尺度 = 尺寸+滤波

## 高斯金字塔 尺度空间

高斯金字塔中一共生成o组l层不同尺度的图像（尺度还是由于高斯核不同引起的，(o,l)构成了高斯金字塔的尺度空间，唯一的（O，L）便可以表示高斯金字塔中的一个尺度。


https://www.cnblogs.com/invisible2/p/9188742.html



## 尺度空间 近大远小的真实含义

因为高斯金字塔中 图像尺寸变小（源图像的四分之一）但使用和源图像相同的高斯核 即 表示在源图像上使用4倍的高斯核，高斯核越大 表示图像越模糊，而越模糊表示在真实世界中物体越远。即使尺寸等同于源图像，也是将远处物体放大的意思。
## 上采样


 缩小图像（或称为下采样（subsampled）或降采样（downsampled））的主要目的有两个：1、使得图像符合显示区域的大小；2、生成对应图像的缩略图。

 放大图像（或称为上采样（upsampling）或图像插值（interpolating））的主要目的是放大原图像,从而可以显示在更高分辨率的显示设备上。

 对图像的缩放操作并不能带来更多关于该图像的信息, 因此图像的质量将不可避免地受到影响。然而，确实有一些缩放方法能够增加图像的信息，从而使得缩放后的图像质量超过原图质量的。

  下采样原理：对于一副图像I尺寸为M*N，对起进行s倍下采样，即得到（M/s）*（N/s）尺寸的分辨率图像，当然，s应该是M和N的公约数才可以，如果考虑是矩阵形式的图像，就是把原始图像s*s窗口内的图像编程一个像素，这个像素点的值就是窗口内所有像素的均值。

  Pk = Σ Ii / s2

  上采样原理：图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。

  插值算法还包括了传统插值，基于边缘图像的插值，还有基于区域的图像插值。
## 得到离散空间中的最大值
在DOG空间中，利用上下层加上本层中的共26个像素点 和当前层中当前的像素点进行比较，如果是极值点，得到的极值点 不仅有x y坐标还有空间尺度坐标。


## 子像素元插值获得连续空间中的最大值


代码如下:

Vec3f dD((img.at<sift_wt>(r, c + 1) - img.at<sift_wt>(r, c - 1))*deriv_scale,//偏x导树，在当前层内计算 
    (img.at<sift_wt>(r + 1, c) - img.at<sift_wt>(r - 1, c))*deriv_scale,//偏y导数，在当前层内计算
    (next.at<sift_wt>(r, c) - prev.at<sift_wt>(r, c))*deriv_scale);//尺度空间导数，在上下两层中计算
// dD为一阶差分矢量Df/Dx
float v2 = (float)img.at<sift_wt>(r, c) * 2;
float dxx = (img.at<sift_wt>(r, c + 1) + img.at<sift_wt>(r, c - 1) - v2)*second_deriv_scale;//偏x二阶导数，当前层中计算
float dyy = (img.at<sift_wt>(r + 1, c) + img.at<sift_wt>(r - 1, c) - v2)*second_deriv_scale;//偏y二阶导数，当前层中计算
float dss = (next.at<sift_wt>(r, c) + prev.at<sift_wt>(r, c) - v2)*second_deriv_scale;//偏尺度空加二阶导数，上下层中计算
float dxy = (img.at<sift_wt>(r + 1, c + 1) - img.at<sift_wt>(r + 1, c - 1) -
    img.at<sift_wt>(r - 1, c + 1) + img.at<sift_wt>(r - 1, c - 1))*cross_deriv_scale;//在同一层中 ，8联通区域中 （右下角-右上角）-（左下角-左上角）
float dxs = (next.at<sift_wt>(r, c + 1) - next.at<sift_wt>(r, c - 1) -
    prev.at<sift_wt>(r, c + 1) + prev.at<sift_wt>(r, c - 1))*cross_deriv_scale;//在不同层中，关于x的导数
float dys = (next.at<sift_wt>(r + 1, c) - next.at<sift_wt>(r - 1, c) -
    prev.at<sift_wt>(r + 1, c) + prev.at<sift_wt>(r - 1, c))*cross_deriv_scale;//在不不同层中，关于y的导数

Matx33f H(dxx, dxy, dxs,
    dxy, dyy, dys,
    dxs, dys, dss);
// dD + Hx = 0  -->  x = H^-1 * (-dD)
Vec3f X = H.solve(dD, DECOMP_LU);




## 消除边缘效应
上式中，𝐷值可以通过求取邻近点像素的差分得到。𝐻的特征值与𝐷的主曲率成正比例。我们可以避免求取具体的特征值，因为我们只关心特征值的比例。令𝛼=𝜆𝑚𝑎𝑥为最大的特征值，𝛽=𝜆𝑚𝑖𝑛为最小的特征值，那么，我们通过𝐻矩阵直迹计算它们的和，通过𝐻

矩阵的行列式计算它们的乘积：

𝑇𝑟(𝐻)=𝐷𝑥𝑥+𝐷𝑦𝑦=𝛼+𝛽

𝐷𝑒𝑡(𝐻)=𝐷𝑥𝑥𝐷𝑦𝑦−(𝐷𝑥𝑦)2=𝛼𝛽

如果𝛾
为最大特征值与最小特征值之间的比例，那么𝛼=𝛾𝛽

，这样便有

(𝑇𝑟(𝐻)*𝑇𝑟(𝐻))/𝐷𝑒𝑡(𝐻)=(𝛼+𝛽)*(𝛼+𝛽)𝛼𝛽=(𝛾+1)*(𝛾+1)/𝛾  小于（10+1）×（10+1）/10

上式的结果只与两个特征值的比例有关，而与具体特征值无关。当两个特征值相等时，(𝛾+1)2𝛾
的值最小，随着𝛾的增加，(𝛾+1)2𝛾的值也增加。所以要想检查主曲率的比例小于某一阈值𝛾

，只要检查下式是否成立,一般取阈值𝛾为10：

𝑇𝑟(𝐻)*𝑇𝑟(𝐻)/𝐷𝑒𝑡(𝐻)<(𝛾+1)2𝛾